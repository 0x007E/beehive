/*-------------------------------------------------------------------------*\
| Datei:        molibdisplay.c
| Version:      1.0
| Projekt:      Display-Bibliothek fuer die MEGACARD V5.5
| Beschreibung: Bibliotheksfunktionen (Implementierung)
| Schaltung:    MEGACARD V5.5
| Autor:        D.I. Leopold Moosbrugger
| Erstellung:   3.3.2022
|
| Aenderung:
\*-------------------------------------------------------------------------*/
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <stdio.h>
#include <stdarg.h>
#include <util/delay.h>
#include "molibdisplay.h" // Schnittstellendefinitionen


// Sevice Bereich SW-I2C Schnittstelle für das Display------------------------------


#ifdef TWI_S_FAST
   // Pause TWI 400kHz / I2C Fast 
   // 1us
   #define TWI_S_DELAY1() _delay_us(0.7)
   // 2us
   #define TWI_S_DELAY2() _delay_us(1.5)
#else
   // Pause TWI 100kHz / I2C Standard
   // 1us
   #define TWI_S_DELAY1() _delay_us(3.0)
   // 2us
   #define TWI_S_DELAY2() _delay_us(6.0)
#endif

#define P_SCL_LIN (1<<PSCL_TWI_S)
#define P_SDA_LIN (1<<PSDA_TWI_S)


// Definitionen fuer die Tackt- und die Datenleitung
// Open Drain
//    Low  => DDR->Ausgang, PORT->Low (0)
//    High => DDR->Eingang, PORT->kein PU (0) 
#define SDA_PSEC  (PRT_TWI_S &= ~P_SDA_LIN)
#define SDA_HIGH  (DDR_TWI_S &= ~P_SDA_LIN)
#define SDA_LOW   (DDR_TWI_S |=  P_SDA_LIN)
#define SDA_IN    (PIN_TWI_S & P_SDA_LIN)

//#define SCL_PSEC  (PRT_TWI_S &= ~P_SCL_LIN)
//#define SCL_HIGH  (DDR_TWI_S &= ~P_SCL_LIN)
//#define SCL_LOW   (DDR_TWI_S |=  P_SCL_LIN)
//#define SCL_IN    (PIN_TWI_S & P_SCL_LIN)


// Definitionen fuer die Tackt- und die Datenleitung
// Aktive Leitunge (Testbetrieb ohne Baustein)
//    Low  => DDR->Ausgang, PORT->Low (0)
//    High => DDR->Ausgang, PORT->High (1)
//#define SDA_PSEC  (DDR_TWI_S |=  P_SDA_LIN)
//#define SDA_HIGH  (PRT_TWI_S |=  P_SDA_LIN)
//#define SDA_LOW   (PRT_TWI_S &= ~P_SDA_LIN)
//#define SDA_IN    (PIN_TWI_S & P_SDA_LIN)
//
#define SCL_PSEC  (DDR_TWI_S |=  P_SCL_LIN)
#define SCL_HIGH  (PRT_TWI_S |=  P_SCL_LIN)
#define SCL_LOW   (PRT_TWI_S &= ~P_SCL_LIN)
#define SCL_IN    (PIN_TWI_S & P_SCL_LIN)


// Init TWI
void twi_s_init(void)
{
/* SCL XXX/''''
   SDA XX/'''''
*/

   SDA_HIGH; // SDA_HIGH;
   SDA_PSEC;
   SCL_HIGH; // SCL_HIGH;
   SCL_PSEC;
}

// Start TWI
uint8_t twi_s_start(uint8_t address)
{
/* SCL ''''\...
   SDA '\......
*/
   SDA_PSEC;
   SCL_PSEC;
   SDA_LOW; TWI_S_DELAY2();
   SCL_LOW; TWI_S_DELAY2();
   
   return twi_s_write(address);
}

// Stop TWI
void twi_s_stop(void)
{
/* SCL ..../''''''
   SDA '\....../''
*/   
   SDA_PSEC;
   SCL_PSEC;
   SDA_LOW;  TWI_S_DELAY2();
   SCL_HIGH; TWI_S_DELAY2();
   SDA_HIGH; TWI_S_DELAY2();
}

// TWI schreiben
uint8_t twi_s_write(uint8_t data)
{
   uint8_t i;
   uint8_t hlp;

   SDA_PSEC;
   SCL_PSEC;
  
/* SCL .../'0'\../'1'\../'2'\../'3'\../'4'\../'5'\../'6'\../'7'\../'A\
   SDA 'X======X======X======X======X======X======X======X======/'''''
*/  
   for (i=0;i<8;i++)
   {  // 8 Bit ausgeben
      if ((data & (1<<7)) != 0)
         SDA_HIGH; // wenn Bit gesetzt
      else
         SDA_LOW;  // wenn Bit nicht gesetzt

      data <<= 1;  // Bit schieben, 7 bis 0
      TWI_S_DELAY1();
      SCL_HIGH;
      TWI_S_DELAY2();
      SCL_LOW;
   }

   SDA_HIGH;
   TWI_S_DELAY1();
   SCL_HIGH;
   TWI_S_DELAY1();

   if (SDA_IN == 0) // Testen SDA auf Acknowledge low
      hlp = ACK;    // Flag Ack setzen
   else
      hlp = NACK;   // sonst Flag Ack loeschen

   SCL_LOW;
   
   return hlp;
}

// TWI Byte lesen

uint8_t twi_s_read(uint8_t ack)
{
   uint8_t data = 0;
   uint8_t i;

   SDA_PSEC;
   SCL_PSEC;

/* SCL ./'0\../'1\../'2\../'3\../'4\../'5\../'6\../'7\../''\.
   SDA ===D=====D=====D=====D=====D=====D=====D=====D=A=====/
*/
   for (i=0;i<8;i++)
   {  // 8 Bit ausgeben
      data <<= 1;			// Bit schieben, 7 bis 0
      TWI_S_DELAY1();
      SCL_HIGH;
      TWI_S_DELAY1();
      if (SDA_IN != 0) // Testen SDA auf high
         data |= 1;    // wenn high, Bit 0 setzen
      SCL_LOW;
   }

   if (ack)
      SDA_LOW;  // Acknowledge
   else
      SDA_HIGH;  // No Acknowledge
   
   TWI_S_DELAY1();
   SCL_HIGH;
   TWI_S_DELAY2();
   SCL_LOW;
   SDA_HIGH;

   return data;  // Daten zurückgeben
}
// Sevice Bereich SW-I2C Schnittstelle für das Display------------------------------

// Zeichnesatz-Code-----------------------------------------------------------------
// Auswahl des Zeichensatzes
// #define FONT_7x8
#define FONT_5x8

#if defined (FONT_7x8)
// erstes Zeichen, letztes Zeichen
// Fontbreite, Fonthoehe, Fontspacing
FontParam_t fontParam = {32, 129, 7, 8, 1};

const uint8_t fontData[] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ' '  32
	0x00, 0x06, 0x5F, 0x5F, 0x06, 0x00, 0x00,  // '!'  33
	0x00, 0x07, 0x07, 0x00, 0x07, 0x07, 0x00,  // '"'  34
	0x14, 0x7F, 0x7F, 0x14, 0x7F, 0x7F, 0x14,  // '#'  35
	0x24, 0x2E, 0x6B, 0x6B, 0x3A, 0x12, 0x00,  // '$'  36
	0x46, 0x66, 0x30, 0x18, 0x0C, 0x66, 0x62,  // '%'  37
	0x30, 0x7A, 0x4F, 0x5D, 0x37, 0x7A, 0x48,  // '&'  38
	0x04, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00,  // '''  39
	0x00, 0x1C, 0x3E, 0x63, 0x41, 0x00, 0x00,  // '('  40
	0x00, 0x41, 0x63, 0x3E, 0x1C, 0x00, 0x00,  // ')'  41
	0x08, 0x2A, 0x3E, 0x1C, 0x1C, 0x3E, 0x2A,  // '*'  42
	0x08, 0x08, 0x3E, 0x3E, 0x08, 0x08, 0x00,  // '+'  43
	0x00, 0x80, 0xE0, 0x60, 0x00, 0x00, 0x00,  // ', ' 44
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,  // '-'  45
	0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00,  // '.'  46
	0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01,  // '/'  47
	0x3E, 0x7F, 0x71, 0x59, 0x4D, 0x7F, 0x3E,  // '0'  48
	0x40, 0x42, 0x7F, 0x7F, 0x40, 0x40, 0x00,  // '1'  49
	0x62, 0x73, 0x59, 0x49, 0x6F, 0x66, 0x00,  // '2'  50
	0x22, 0x63, 0x49, 0x49, 0x7F, 0x36, 0x00,  // '3'  51
	0x18, 0x1C, 0x16, 0x53, 0x7F, 0x7F, 0x50,  // '4'  52
	0x27, 0x67, 0x45, 0x45, 0x7D, 0x39, 0x00,  // '5'  53
	0x3C, 0x7E, 0x4B, 0x49, 0x79, 0x30, 0x00,  // '6'  54
	0x03, 0x03, 0x71, 0x79, 0x0F, 0x07, 0x00,  // '7'  55
	0x36, 0x7F, 0x49, 0x49, 0x7F, 0x36, 0x00,  // '8'  56
	0x06, 0x4F, 0x49, 0x69, 0x3F, 0x1E, 0x00,  // '9'  57
	0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00,  // ':'  58
	0x00, 0x80, 0xE6, 0x66, 0x00, 0x00, 0x00,  // ';'  59
	0x08, 0x1C, 0x36, 0x63, 0x41, 0x00, 0x00,  // '<'  60
	0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00,  // '='  61
	0x00, 0x41, 0x63, 0x36, 0x1C, 0x08, 0x00,  // '>'  62
	0x02, 0x03, 0x51, 0x59, 0x0F, 0x06, 0x00,  // '?'  63
	0x3E, 0x7F, 0x41, 0x5D, 0x5D, 0x1F, 0x1E,  // '@'  64
	0x7C, 0x7E, 0x13, 0x13, 0x7E, 0x7C, 0x00,  // 'A'  65
	0x41, 0x7F, 0x7F, 0x49, 0x49, 0x7F, 0x36,  // 'B'  66
	0x1C, 0x3E, 0x63, 0x41, 0x41, 0x63, 0x22,  // 'C'  67
	0x41, 0x7F, 0x7F, 0x41, 0x63, 0x3E, 0x1C,  // 'D'  68
	0x41, 0x7F, 0x7F, 0x49, 0x5D, 0x41, 0x63,  // 'E'  69
	0x41, 0x7F, 0x7F, 0x49, 0x1D, 0x01, 0x03,  // 'F'  70
	0x1C, 0x3E, 0x63, 0x41, 0x51, 0x73, 0x72,  // 'G'  71
	0x7F, 0x7F, 0x08, 0x08, 0x7F, 0x7F, 0x00,  // 'H'  72
	0x00, 0x41, 0x7F, 0x7F, 0x41, 0x00, 0x00,  // 'I'  73
	0x30, 0x70, 0x40, 0x41, 0x7F, 0x3F, 0x01,  // 'J'  74
	0x41, 0x7F, 0x7F, 0x08, 0x1C, 0x77, 0x63,  // 'K'  75
	0x41, 0x7F, 0x7F, 0x41, 0x40, 0x60, 0x70,  // 'L'  76
	0x7F, 0x7F, 0x0E, 0x1C, 0x0E, 0x7F, 0x7F,  // 'M'  77
	0x7F, 0x7F, 0x06, 0x0C, 0x18, 0x7F, 0x7F,  // 'N'  78
	0x1C, 0x3E, 0x63, 0x41, 0x63, 0x3E, 0x1C,  // 'O'  79
	0x41, 0x7F, 0x7F, 0x49, 0x09, 0x0F, 0x06,  // 'P'  80
	0x1E, 0x3F, 0x21, 0x71, 0x7F, 0x5E, 0x00,  // 'Q'  81
	0x41, 0x7F, 0x7F, 0x09, 0x19, 0x7F, 0x66,  // 'R'  82
	0x26, 0x6F, 0x4D, 0x59, 0x73, 0x32, 0x00,  // 'S'  83
	0x03, 0x41, 0x7F, 0x7F, 0x41, 0x03, 0x00,  // 'T'  84
	0x7F, 0x7F, 0x40, 0x40, 0x7F, 0x7F, 0x00,  // 'U'  85
	0x1F, 0x3F, 0x60, 0x60, 0x3F, 0x1F, 0x00,  // 'V'  86
	0x7F, 0x7F, 0x30, 0x18, 0x30, 0x7F, 0x7F,  // 'W'  87
	0x43, 0x67, 0x3C, 0x18, 0x3C, 0x67, 0x43,  // 'X'  88
	0x07, 0x4F, 0x78, 0x78, 0x4F, 0x07, 0x00,  // 'Y'  89
	0x47, 0x63, 0x71, 0x59, 0x4D, 0x67, 0x73,  // 'Z'  90
	0x00, 0x7F, 0x7F, 0x41, 0x41, 0x00, 0x00,  // '['  91
	0x01, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60,  // '\'  92
	0x00, 0x41, 0x41, 0x7F, 0x7F, 0x00, 0x00,  // ']'  93
	0x08, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x08,  // '^'  94
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,  // '_'  95
	0x00, 0x00, 0x03, 0x07, 0x04, 0x00, 0x00,  // '`'  96
	0x20, 0x74, 0x54, 0x54, 0x3C, 0x78, 0x40,  // 'a'  97
	0x41, 0x7F, 0x3F, 0x48, 0x48, 0x78, 0x30,  // 'b'  98
	0x38, 0x7C, 0x44, 0x44, 0x6C, 0x28, 0x00,  // 'c'  99
	0x30, 0x78, 0x48, 0x49, 0x3F, 0x7F, 0x40,  // 'd' 100
	0x38, 0x7C, 0x54, 0x54, 0x5C, 0x18, 0x00,  // 'e' 101
	0x48, 0x7E, 0x7F, 0x49, 0x03, 0x02, 0x00,  // 'f' 102
	0x38, 0xBC, 0xA4, 0xA4, 0xFC, 0x78, 0x00,  // 'g' 103
	0x41, 0x7F, 0x7F, 0x08, 0x04, 0x7C, 0x78,  // 'h' 104
	0x00, 0x44, 0x7D, 0x7D, 0x40, 0x00, 0x00,  // 'i' 105
	0x60, 0xE0, 0x80, 0x80, 0xFD, 0x7D, 0x00,  // 'j' 106
	0x41, 0x7F, 0x7F, 0x10, 0x38, 0x6C, 0x44,  // 'k' 107
	0x00, 0x41, 0x7F, 0x7F, 0x40, 0x00, 0x00,  // 'l' 108
	0x78, 0x7C, 0x1C, 0x38, 0x1C, 0x7C, 0x78,  // 'm' 109
	0x7C, 0x7C, 0x04, 0x04, 0x7C, 0x78, 0x00,  // 'n' 110
	0x38, 0x7C, 0x44, 0x44, 0x7C, 0x38, 0x00,  // 'o' 111
	0x00, 0xFC, 0xFC, 0xA4, 0x24, 0x3C, 0x18,  // 'p' 112
	0x18, 0x3C, 0x24, 0xA4, 0xF8, 0xFC, 0x84,  // 'q' 113
	0x44, 0x7C, 0x78, 0x4C, 0x04, 0x1C, 0x18,  // 'r' 114
	0x48, 0x5C, 0x54, 0x54, 0x74, 0x24, 0x00,  // 's' 115
	0x00, 0x04, 0x3E, 0x7F, 0x44, 0x24, 0x00,  // 't' 116
	0x3C, 0x7C, 0x40, 0x40, 0x3C, 0x7C, 0x40,  // 'u' 117
	0x1C, 0x3C, 0x60, 0x60, 0x3C, 0x1C, 0x00,  // 'v' 118
	0x3C, 0x7C, 0x70, 0x38, 0x70, 0x7C, 0x3C,  // 'w' 119
	0x44, 0x6C, 0x38, 0x10, 0x38, 0x6C, 0x44,  // 'x' 120
	0x3C, 0xBC, 0xA0, 0xA0, 0xFC, 0x7C, 0x00,  // 'y' 121
	0x4C, 0x64, 0x74, 0x5C, 0x4C, 0x64, 0x00,  // 'z' 122
	0x08, 0x08, 0x3E, 0x77, 0x41, 0x41, 0x00,  // '{' 123
		0x00, 0x00, 0x00, 0x77, 0x77, 0x00, 0x00,  // '|' 124
	0x41, 0x41, 0x77, 0x3E, 0x08, 0x08, 0x00,  // '}' 125
	0x02, 0x03, 0x01, 0x03, 0x02, 0x03, 0x01,  // '~' 126
	0xDB, 0xAB, 0x18, 0x18, 0x00, 0xFF, 0xFF,  // HTL H 127
	0x03, 0x03, 0xFF, 0xFF, 0x00, 0x03, 0x03,  // HTL T 128
	0xFF, 0xFF, 0x00, 0xC0, 0xC0, 0xC0, 0xC0   // HTL L 129
};

#elif defined (FONT_5x8)

// erstes Zeichen, letztes Zeichen
// Fontbreite, Fonthoehe, Fontspacing
FontParam_t fontParam = {32, 127, 5, 8, 2};

const unsigned char fontData[] PROGMEM =
{
	0x00, 0x00, 0x00, 0x00, 0x00,      // Code for char
	0x00, 0x00, 0x5F, 0x00, 0x00,      // Code for char !
	0x00, 0x07, 0x00, 0x07, 0x00,      // Code for char "
	0x14, 0x7F, 0x14, 0x7F, 0x14,      // Code for char #
	0x24, 0x2A, 0x7F, 0x2A, 0x12,      // Code for char $
	0x23, 0x13, 0x08, 0x64, 0x62,      // Code for char %
	0x36, 0x49, 0x56, 0x20, 0x50,      // Code for char &
	0x08, 0x07, 0x03, 0x00, 0x00,      // Code for char '
	0x00, 0x1C, 0x22, 0x41, 0x00,      // Code for char (
	0x00, 0x41, 0x22, 0x1C, 0x00,      // Code for char )
	0x14, 0x08, 0x3E, 0x08, 0x14,      // Code for char *
	0x08, 0x08, 0x3E, 0x08, 0x08,      // Code for char +
	0x00, 0xB0, 0x70, 0x00, 0x00,      // Code for char ,
	0x08, 0x08, 0x08, 0x08, 0x08,      // Code for char -
	0x00, 0x60, 0x60, 0x00, 0x00,      // Code for char .
	0x20, 0x10, 0x08, 0x04, 0x02,      // Code for char /
	0x3E, 0x51, 0x49, 0x45, 0x3E,      // Code for char 0
	0x00, 0x42, 0x7F, 0x40, 0x00,      // Code for char 1
	0x72, 0x49, 0x49, 0x49, 0x46,      // Code for char 2
	0x21, 0x41, 0x49, 0x4D, 0x33,      // Code for char 3
	0x18, 0x14, 0x12, 0x7F, 0x10,      // Code for char 4
	0x27, 0x45, 0x45, 0x45, 0x39,      // Code for char 5
	0x3C, 0x4A, 0x49, 0x49, 0x31,      // Code for char 6
	0x41, 0x21, 0x11, 0x09, 0x07,      // Code for char 7
	0x36, 0x49, 0x49, 0x49, 0x36,      // Code for char 8
	0x46, 0x49, 0x49, 0x29, 0x1E,      // Code for char 9
	0x00, 0x00, 0x14, 0x00, 0x00,      // Code for char :
	0x00, 0x40, 0x34, 0x00, 0x00,      // Code for char ;
	0x08, 0x14, 0x22, 0x41, 0x00,      // Code for char <
	0x14, 0x14, 0x14, 0x14, 0x14,      // Code for char =
	0x41, 0x22, 0x14, 0x08, 0x00,      // Code for char >
	0x02, 0x01, 0x59, 0x09, 0x06,      // Code for char ?
	0x3E, 0x41, 0x5D, 0x59, 0x4E,      // Code for char @
	0x7C, 0x12, 0x11, 0x12, 0x7C,      // Code for char A
	0x7F, 0x49, 0x49, 0x49, 0x36,      // Code for char B
	0x3E, 0x41, 0x41, 0x41, 0x22,      // Code for char C
	0x7F, 0x41, 0x41, 0x41, 0x3E,      // Code for char D
	0x7F, 0x49, 0x49, 0x49, 0x49,      // Code for char E
	0x7F, 0x09, 0x09, 0x09, 0x09,      // Code for char F
	0x3E, 0x41, 0x41, 0x51, 0x73,      // Code for char G
	0x7F, 0x08, 0x08, 0x08, 0x7F,      // Code for char H
	0x00, 0x41, 0x7F, 0x41, 0x00,      // Code for char I
	0x20, 0x40, 0x41, 0x3F, 0x01,      // Code for char J
	0x7F, 0x08, 0x14, 0x22, 0x41,      // Code for char K
	0x7F, 0x40, 0x40, 0x40, 0x40,      // Code for char L
	0x7F, 0x02, 0x0C, 0x02, 0x7F,      // Code for char M
	0x7F, 0x04, 0x08, 0x10, 0x7F,      // Code for char N
	0x3E, 0x41, 0x41, 0x41, 0x3E,      // Code for char O
	0x7F, 0x09, 0x09, 0x09, 0x06,      // Code for char P
	0x3E, 0x41, 0x51, 0x21, 0x5E,      // Code for char Q
	0x7F, 0x09, 0x19, 0x29, 0x46,      // Code for char R
	0x26, 0x49, 0x49, 0x49, 0x32,      // Code for char S
	0x01, 0x01, 0x7F, 0x01, 0x01,      // Code for char T
	0x3F, 0x40, 0x40, 0x40, 0x3F,      // Code for char U
	0x1F, 0x20, 0x40, 0x20, 0x1F,      // Code for char V
	0x3F, 0x40, 0x38, 0x40, 0x3F,      // Code for char W
	0x63, 0x14, 0x08, 0x14, 0x63,      // Code for char X
	0x03, 0x04, 0x78, 0x04, 0x03,      // Code for char Y
	0x61, 0x51, 0x49, 0x45, 0x43,      // Code for char Z
	0x00, 0x7F, 0x41, 0x41, 0x00,      // Code for char [
	0x02, 0x04, 0x08, 0x10, 0x20,      // Code for char BackSlash
	0x00, 0x41, 0x41, 0x7F, 0x00,      // Code for char ]
	0x04, 0x02, 0x01, 0x02, 0x04,      // Code for char ^
	0x40, 0x40, 0x40, 0x40, 0x40,      // Code for char _
	0x07, 0x0B, 0x00, 0x00, 0x00,      // Code for char `
	0x20, 0x54, 0x54, 0x78, 0x40,      // Code for char a
	0x7F, 0x28, 0x44, 0x44, 0x38,      // Code for char b
	0x38, 0x44, 0x44, 0x44, 0x28,      // Code for char c
	0x38, 0x44, 0x44, 0x28, 0x7F,      // Code for char d
	0x38, 0x54, 0x54, 0x54, 0x18,      // Code for char e
	0x00, 0x08, 0x7E, 0x09, 0x02,      // Code for char f
	0x18, 0xA4, 0xA4, 0x9C, 0x78,      // Code for char g
	0x7F, 0x08, 0x04, 0x04, 0x78,      // Code for char h
	0x00, 0x44, 0x7D, 0x40, 0x00,      // Code for char i
	0x20, 0x40, 0x40, 0x3D, 0x00,      // Code for char j
	0x7F, 0x10, 0x28, 0x44, 0x00,      // Code for char k
	0x00, 0x41, 0x7F, 0x40, 0x00,      // Code for char l
	0x7C, 0x04, 0x78, 0x04, 0x78,      // Code for char m
	0x7C, 0x08, 0x04, 0x04, 0x78,      // Code for char n
	0x38, 0x44, 0x44, 0x44, 0x38,      // Code for char o
	0xFC, 0x18, 0x24, 0x24, 0x18,      // Code for char p
	0x18, 0x24, 0x24, 0x18, 0xFC,      // Code for char q
	0x7C, 0x08, 0x04, 0x04, 0x08,      // Code for char r
	0x48, 0x54, 0x54, 0x54, 0x24,      // Code for char s
	0x04, 0x04, 0x3F, 0x44, 0x24,      // Code for char t
	0x3C, 0x40, 0x40, 0x20, 0x7C,      // Code for char u
	0x1C, 0x20, 0x40, 0x20, 0x1C,      // Code for char v
	0x3C, 0x40, 0x30, 0x40, 0x3C,      // Code for char w
	0x44, 0x28, 0x10, 0x28, 0x44,      // Code for char x
	0x4C, 0x90, 0x90, 0x90, 0x7C,      // Code for char y
	0x44, 0x64, 0x54, 0x4C, 0x44,      // Code for char z
	0x00, 0x08, 0x36, 0x41, 0x00,      // Code for char {
		0x00, 0x00, 0x77, 0x00, 0x00,      // Code for char |
	0x00, 0x41, 0x36, 0x08, 0x00,      // Code for char }
	0x04, 0x02, 0x04, 0x08, 0x04,      // Code for char ~
	0x00, 0x7F, 0x41, 0x7F, 0x00       // Code for char 
};

#else
#    warning "Font type not defined"
#endif



// Zeichnesatz-Code-----------------------------------------------------------------


// Lokale Makros
#define OLED_CTRL_BYTE_CMD  0x80 // 0b1000 0000
#define OLED_CTRL_BYTE_DATA 0x40 // 0b0100 0000
#define OLED_DEV_ADDR 0x78       // 0b0111 1000

#define OLED_PAGES 8
#define OLED_PIXEL_X 128
#define OLED_PIXEL_Y 64

#define DISP_LINES (OLED_PIXEL_Y/fontParam.height)
#define DISP_COLS (OLED_PIXEL_X/(fontParam.width+fontParam.spacing))

#define  OLED_SEND_CMD(value)  {twi_s_write(OLED_CTRL_BYTE_CMD); twi_s_write((value));}

// Modullokale Variablen
static uint8_t d_offset = 0;

// Display initialisieren und einschalten
void display_init(void)
{
	// Initialisierung der SW-I2C Schnittstelle
	twi_s_init();
	
	// Initialisierungssequenzen senden
	// Siehe Application Note [SOLOMON SYSTECH]
	// http://www.solomon-systech.com

	twi_s_start(OLED_DEV_ADDR);
	OLED_SEND_CMD(0xA8); // Set Mux Ratio
	OLED_SEND_CMD(0x3F); // S32 (R)

	OLED_SEND_CMD(0xD3); // Set Display offset
	OLED_SEND_CMD(0x00); // S33 (R)

	OLED_SEND_CMD(0x40); // Set Segment Start Line S32 (R)

	OLED_SEND_CMD(0xA0); // Set Segment re-map S32 (R)

	OLED_SEND_CMD(0xC0); // Set COM Output Scan Direction S32 (R)

	OLED_SEND_CMD(0xDA); // Set COM Pins hardware configuration
	OLED_SEND_CMD(0x12); // S33 (R)

	OLED_SEND_CMD(0x81); // Set Contrast Control
	OLED_SEND_CMD(0x7F); // S27 (R)

	OLED_SEND_CMD(0xA4); // Disable Entre Display On S27 (R)

	OLED_SEND_CMD(0xA6); // Set Normal Display S27 (R)

	OLED_SEND_CMD(0xD5); // Set Osc Frequency
	OLED_SEND_CMD(0x80); // S33 (R)

	OLED_SEND_CMD(0x20); // Page addressing Mode
	OLED_SEND_CMD(0x02); // S31 (R)

	OLED_SEND_CMD(0x8D); // Enable charge pump regulator
	OLED_SEND_CMD(0x14); // during display on 7.5V S34 (R)
	twi_s_stop();

	display_clear();
	
	display_printf_pos(0,3,"HTLR OLED Display\n");
	display_printf_pos(0,4,"%u Zeichen",display_chars());
	display_printf_pos(0,5,"%u Zeilen",display_lines());

	
	// Modullokale Variablen initialisieren
	d_offset = 0;
		
	twi_s_start(OLED_DEV_ADDR);
	OLED_SEND_CMD(0xAF); // Display ON S27
	twi_s_stop();	
}

// Informationsfunktionen zur Anzeige
uint8_t display_lines (void)
{
	return DISP_LINES;
}

uint8_t display_chars (void)
{
	return DISP_COLS;
}

uint8_t display_char_first (void)
{
	return fontParam.char_first;
}

uint8_t display_char_last (void)
{
	return fontParam.char_last;
}

// Anzeigefunktionen (Implementierung)
void display_scroll_up (void)
{
	uint8_t ic;

	// oberste Zeile loeschen
	display_pos(0, 0);

	twi_s_start(OLED_DEV_ADDR);
	twi_s_write(OLED_CTRL_BYTE_DATA);
	// gesamte Page loeschen
	for(ic=0; ic<OLED_PIXEL_X; ic++)
	{
		twi_s_write(0x00);
	}
	twi_s_stop();

	d_offset += 1;
	if (d_offset >= DISP_LINES)
	d_offset -= DISP_LINES;

	twi_s_start(OLED_DEV_ADDR);
	OLED_SEND_CMD(0xD3); // Set Display offset
	OLED_SEND_CMD(d_offset<<3); // S33
	twi_s_stop();
}

void display_scroll_down (void)
{
	uint8_t ic;

	// unterste Zeile loeschen
	display_pos(0, DISP_LINES-1);

	twi_s_start(OLED_DEV_ADDR);
	twi_s_write(OLED_CTRL_BYTE_DATA);
	// gesamte Page loeschen
	for(ic=0; ic<OLED_PIXEL_X; ic++)
	{
		twi_s_write(0x00);
	}
	twi_s_stop();

	if (d_offset > 0)
	{
		d_offset--;
	} else
	{
		d_offset = DISP_LINES - 1;
	}

	twi_s_start(OLED_DEV_ADDR);
	OLED_SEND_CMD(0xD3); // Set Display offset
	OLED_SEND_CMD(d_offset<<3); // S33
	twi_s_stop();
}
// Setzt den Cursor an eine beliebige Position im Display
// Bei Ueberschreiten der Limite (DISP_LINES, DISP_COLS) bleibt
// der Cursor unveraendert. (Zaehler beginnt bei 0)
// x-Position von links nach rechts, y-Position von oben nach unten
void display_pos(uint8_t col, uint8_t row)
{
	uint8_t pixel_col;

	// ungueltige Parameter abfangen
	if ((row < DISP_LINES) && (col < DISP_COLS))
	{
		pixel_col = col * (fontParam.width+fontParam.spacing);

		// Zeilenadresse anpassen
		row += d_offset;
		if (row >= DISP_LINES)
		row -= DISP_LINES;

		twi_s_start(OLED_DEV_ADDR);
		// Seitenadresse setzen
		OLED_SEND_CMD((0b10110000 | row));

		// unteres Nibble der Col-Addresse ((col*8) & 0x0F)
		OLED_SEND_CMD(pixel_col & 0x0F);

		// oberes Nibble der Col-Addresse ((col*8/16) & 0x0F)
		OLED_SEND_CMD(0x10 | ((pixel_col>>4) & 0x0F));

		twi_s_stop();
	}
}

// Loescht den Inhalt des Displays und setzt den Cursor oben links (Home)
void display_clear(void)
{
	uint8_t ip, ic;
	
	// Alle Speicher Pages loeschen
	for(ip=0; ip<OLED_PAGES; ip++)
	{
		display_pos(0, ip);

		twi_s_start(OLED_DEV_ADDR);
		twi_s_write(OLED_CTRL_BYTE_DATA);
		// gesamte Page loeschen
		for(ic=0; ic<OLED_PIXEL_X; ic++)
		{
			twi_s_write(0x00);
		}
		twi_s_stop();
	}

	// Cursor in Position 0, 0
	display_pos(0, 0);
}

// Ausgabe eines Zeichens an der aktuellen Position
void display_char (uint8_t c)
{
	uint8_t cnt;
	uint16_t f_index;
	
	// Ungueltige Zeichen abfangen (erstes Zeichen imZeichensatz)
	if ((c < fontParam.char_first) || (c > fontParam.char_last))
	c = fontParam.char_first;
	
	// Index im FontData-Arry berechnen
	f_index = (c - fontParam.char_first) * fontParam.width;

	// write zero to next GDRAM Position
	twi_s_start(OLED_DEV_ADDR);
	twi_s_write(OLED_CTRL_BYTE_DATA);

	// Display character c at current position
	for (cnt=0; cnt<fontParam.width; cnt++)
	{
		twi_s_write(pgm_read_byte(&fontData[f_index++]));
	}

	// Spacing ausgeben
	for (cnt=0; cnt<fontParam.spacing; cnt++)
	{
		twi_s_write(0);
	}

	twi_s_stop();
}

void display_string (char *line)
{
	while (*line)
	display_char(*line++);
}

void display_string_pos (uint8_t posx, uint8_t posy, char *line)
{
	display_pos(posx, posy);
	display_string(line);
}

int8_t  display_printf(const char *fmt, ...)
{
	char buf[25];
	int8_t c_count;

	va_list args;
	va_start(args, fmt);
	c_count = vsnprintf(buf, sizeof buf, fmt, args);
	va_end(args);
	
	if (c_count >= 0)
	display_string(buf);
	return c_count;
}

int8_t display_printf_pos(uint8_t posx, uint8_t posy, const char *fmt, ...)
{
	char buf[25];
	int8_t c_count;
	
	va_list args;
	va_start(args, fmt);
	c_count = vsnprintf(buf, sizeof buf, fmt, args);
	va_end(args);
	
	if (c_count >= 0)
	display_string_pos(posx, posy, buf);
	return c_count;
}

void display_pixel_byte (uint8_t pcol, uint8_t prow, uint8_t pbyte)
{
	if ((prow < OLED_PIXEL_Y) && (pcol < OLED_PIXEL_X))
	{
		prow >>= 3; // prow / 8

		twi_s_start(OLED_DEV_ADDR);
		// Seitenadresse setzen
		OLED_SEND_CMD((0b10110000 | prow));
		// unteres Nibble der Col-Addresse ((col*8) & 0x0F)
		OLED_SEND_CMD(pcol & 0x0F);
		// oberes Nibble der Col-Addresse ((col*8/16) & 0x0F)
		OLED_SEND_CMD(0x10 | ((pcol>>4) & 0x0F));
		twi_s_stop();
		
		twi_s_start(OLED_DEV_ADDR);
		twi_s_write(OLED_CTRL_BYTE_DATA);
		twi_s_write(pbyte);
		twi_s_stop();
	}
}